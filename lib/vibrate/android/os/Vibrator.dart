// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'VibrationEffect.dart' as vibrationeffect$_;

/// from: `android.os.Vibrator`
class Vibrator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Vibrator> $type;

  @jni$_.internal
  Vibrator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Vibrator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Vibrator$NullableType();
  static const type = $Vibrator$Type();

  /// from: `static public final int VIBRATION_EFFECT_SUPPORT_NO`
  static const VIBRATION_EFFECT_SUPPORT_NO = 2;

  /// from: `static public final int VIBRATION_EFFECT_SUPPORT_UNKNOWN`
  static const VIBRATION_EFFECT_SUPPORT_UNKNOWN = 0;

  /// from: `static public final int VIBRATION_EFFECT_SUPPORT_YES`
  static const VIBRATION_EFFECT_SUPPORT_YES = 1;
  static final _id_areAllEffectsSupported = _class.instanceMethodId(
    r'areAllEffectsSupported',
    r'([I)I',
  );

  static final _areAllEffectsSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final int areAllEffectsSupported(int[] is)`
  int areAllEffectsSupported(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _areAllEffectsSupported(
      reference.pointer,
      _id_areAllEffectsSupported as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).integer;
  }

  static final _id_areAllPrimitivesSupported = _class.instanceMethodId(
    r'areAllPrimitivesSupported',
    r'([I)Z',
  );

  static final _areAllPrimitivesSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean areAllPrimitivesSupported(int[] is)`
  bool areAllPrimitivesSupported(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _areAllPrimitivesSupported(
      reference.pointer,
      _id_areAllPrimitivesSupported as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).boolean;
  }

  static final _id_areEffectsSupported = _class.instanceMethodId(
    r'areEffectsSupported',
    r'([I)[I',
  );

  static final _areEffectsSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int[] areEffectsSupported(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? areEffectsSupported(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _areEffectsSupported(
      reference.pointer,
      _id_areEffectsSupported as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_areEnvelopeEffectsSupported = _class.instanceMethodId(
    r'areEnvelopeEffectsSupported',
    r'()Z',
  );

  static final _areEnvelopeEffectsSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean areEnvelopeEffectsSupported()`
  bool areEnvelopeEffectsSupported() {
    return _areEnvelopeEffectsSupported(
      reference.pointer,
      _id_areEnvelopeEffectsSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_arePrimitivesSupported = _class.instanceMethodId(
    r'arePrimitivesSupported',
    r'([I)[Z',
  );

  static final _arePrimitivesSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean[] arePrimitivesSupported(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBooleanArray? arePrimitivesSupported(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _arePrimitivesSupported(
      reference.pointer,
      _id_arePrimitivesSupported as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JBooleanArray?>(const jni$_.JBooleanArrayNullableType());
  }

  static final _id_cancel = _class.instanceMethodId(r'cancel', r'()V');

  static final _cancel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void cancel()`
  void cancel() {
    _cancel(reference.pointer, _id_cancel as jni$_.JMethodIDPtr).check();
  }

  static final _id_getEnvelopeEffectInfo = _class.instanceMethodId(
    r'getEnvelopeEffectInfo',
    r'()Landroid/os/vibrator/VibratorEnvelopeEffectInfo;',
  );

  static final _getEnvelopeEffectInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.os.vibrator.VibratorEnvelopeEffectInfo getEnvelopeEffectInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getEnvelopeEffectInfo() {
    return _getEnvelopeEffectInfo(
      reference.pointer,
      _id_getEnvelopeEffectInfo as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getFrequencyProfile = _class.instanceMethodId(
    r'getFrequencyProfile',
    r'()Landroid/os/vibrator/VibratorFrequencyProfile;',
  );

  static final _getFrequencyProfile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.os.vibrator.VibratorFrequencyProfile getFrequencyProfile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFrequencyProfile() {
    return _getFrequencyProfile(
      reference.pointer,
      _id_getFrequencyProfile as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getId = _class.instanceMethodId(r'getId', r'()I');

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getId()`
  int getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getPrimitiveDurations = _class.instanceMethodId(
    r'getPrimitiveDurations',
    r'([I)[I',
  );

  static final _getPrimitiveDurations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int[] getPrimitiveDurations(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getPrimitiveDurations(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _getPrimitiveDurations(
      reference.pointer,
      _id_getPrimitiveDurations as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getQFactor = _class.instanceMethodId(r'getQFactor', r'()F');

  static final _getQFactor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getQFactor()`
  double getQFactor() {
    return _getQFactor(
      reference.pointer,
      _id_getQFactor as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getResonantFrequency = _class.instanceMethodId(
    r'getResonantFrequency',
    r'()F',
  );

  static final _getResonantFrequency =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getResonantFrequency()`
  double getResonantFrequency() {
    return _getResonantFrequency(
      reference.pointer,
      _id_getResonantFrequency as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_hasAmplitudeControl = _class.instanceMethodId(
    r'hasAmplitudeControl',
    r'()Z',
  );

  static final _hasAmplitudeControl =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean hasAmplitudeControl()`
  bool hasAmplitudeControl() {
    return _hasAmplitudeControl(
      reference.pointer,
      _id_hasAmplitudeControl as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_hasVibrator = _class.instanceMethodId(
    r'hasVibrator',
    r'()Z',
  );

  static final _hasVibrator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean hasVibrator()`
  bool hasVibrator() {
    return _hasVibrator(
      reference.pointer,
      _id_hasVibrator as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_vibrate = _class.instanceMethodId(
    r'vibrate',
    r'(Landroid/os/VibrationEffect;)V',
  );

  static final _vibrate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void vibrate(android.os.VibrationEffect vibrationEffect)`
  void vibrate(vibrationeffect$_.VibrationEffect? vibrationEffect) {
    final _$vibrationEffect =
        vibrationEffect?.reference ?? jni$_.jNullReference;
    _vibrate(
      reference.pointer,
      _id_vibrate as jni$_.JMethodIDPtr,
      _$vibrationEffect.pointer,
    ).check();
  }

  static final _id_vibrate$1 = _class.instanceMethodId(
    r'vibrate',
    r'(Landroid/os/VibrationEffect;Landroid/media/AudioAttributes;)V',
  );

  static final _vibrate$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void vibrate(android.os.VibrationEffect vibrationEffect, android.media.AudioAttributes audioAttributes)`
  void vibrate$1(
    vibrationeffect$_.VibrationEffect? vibrationEffect,
    jni$_.JObject? audioAttributes,
  ) {
    final _$vibrationEffect =
        vibrationEffect?.reference ?? jni$_.jNullReference;
    final _$audioAttributes =
        audioAttributes?.reference ?? jni$_.jNullReference;
    _vibrate$1(
      reference.pointer,
      _id_vibrate$1 as jni$_.JMethodIDPtr,
      _$vibrationEffect.pointer,
      _$audioAttributes.pointer,
    ).check();
  }

  static final _id_vibrate$2 = _class.instanceMethodId(
    r'vibrate',
    r'(Landroid/os/VibrationEffect;Landroid/os/VibrationAttributes;)V',
  );

  static final _vibrate$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void vibrate(android.os.VibrationEffect vibrationEffect, android.os.VibrationAttributes vibrationAttributes)`
  void vibrate$2(
    vibrationeffect$_.VibrationEffect? vibrationEffect,
    jni$_.JObject? vibrationAttributes,
  ) {
    final _$vibrationEffect =
        vibrationEffect?.reference ?? jni$_.jNullReference;
    final _$vibrationAttributes =
        vibrationAttributes?.reference ?? jni$_.jNullReference;
    _vibrate$2(
      reference.pointer,
      _id_vibrate$2 as jni$_.JMethodIDPtr,
      _$vibrationEffect.pointer,
      _$vibrationAttributes.pointer,
    ).check();
  }

  static final _id_vibrate$3 = _class.instanceMethodId(r'vibrate', r'(J)V');

  static final _vibrate$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void vibrate(long j)`
  void vibrate$3(int j) {
    _vibrate$3(
      reference.pointer,
      _id_vibrate$3 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_vibrate$4 = _class.instanceMethodId(
    r'vibrate',
    r'(JLandroid/media/AudioAttributes;)V',
  );

  static final _vibrate$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void vibrate(long j, android.media.AudioAttributes audioAttributes)`
  void vibrate$4(int j, jni$_.JObject? audioAttributes) {
    final _$audioAttributes =
        audioAttributes?.reference ?? jni$_.jNullReference;
    _vibrate$4(
      reference.pointer,
      _id_vibrate$4 as jni$_.JMethodIDPtr,
      j,
      _$audioAttributes.pointer,
    ).check();
  }

  static final _id_vibrate$5 = _class.instanceMethodId(r'vibrate', r'([JI)V');

  static final _vibrate$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void vibrate(long[] js, int i)`
  void vibrate$5(jni$_.JLongArray? js, int i) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    _vibrate$5(
      reference.pointer,
      _id_vibrate$5 as jni$_.JMethodIDPtr,
      _$js.pointer,
      i,
    ).check();
  }

  static final _id_vibrate$6 = _class.instanceMethodId(
    r'vibrate',
    r'([JILandroid/media/AudioAttributes;)V',
  );

  static final _vibrate$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void vibrate(long[] js, int i, android.media.AudioAttributes audioAttributes)`
  void vibrate$6(jni$_.JLongArray? js, int i, jni$_.JObject? audioAttributes) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$audioAttributes =
        audioAttributes?.reference ?? jni$_.jNullReference;
    _vibrate$6(
      reference.pointer,
      _id_vibrate$6 as jni$_.JMethodIDPtr,
      _$js.pointer,
      i,
      _$audioAttributes.pointer,
    ).check();
  }
}

final class $Vibrator$NullableType extends jni$_.JObjType<Vibrator?> {
  @jni$_.internal
  const $Vibrator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Vibrator;';

  @jni$_.internal
  @core$_.override
  Vibrator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Vibrator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Vibrator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Vibrator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Vibrator$NullableType) &&
        other is $Vibrator$NullableType;
  }
}

final class $Vibrator$Type extends jni$_.JObjType<Vibrator> {
  @jni$_.internal
  const $Vibrator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Vibrator;';

  @jni$_.internal
  @core$_.override
  Vibrator fromReference(jni$_.JReference reference) =>
      Vibrator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Vibrator?> get nullableType => const $Vibrator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Vibrator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Vibrator$Type) && other is $Vibrator$Type;
  }
}
