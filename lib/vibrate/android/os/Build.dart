// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `android.os.Build$Partition`
class Build$Partition extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build$Partition> $type;

  @jni$_.internal
  Build$Partition.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build$Partition');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build$Partition$NullableType();
  static const type = $Build$Partition$Type();
  static final _id_PARTITION_NAME_SYSTEM = _class.staticFieldId(
    r'PARTITION_NAME_SYSTEM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PARTITION_NAME_SYSTEM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PARTITION_NAME_SYSTEM =>
      _id_PARTITION_NAME_SYSTEM.get(_class, const jni$_.JStringNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_getBuildTimeMillis = _class.instanceMethodId(
    r'getBuildTimeMillis',
    r'()J',
  );

  static final _getBuildTimeMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getBuildTimeMillis()`
  int getBuildTimeMillis() {
    return _getBuildTimeMillis(
      reference.pointer,
      _id_getBuildTimeMillis as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/lang/String;',
  );

  static final _getFingerprint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFingerprint() {
    return _getFingerprint(
      reference.pointer,
      _id_getFingerprint as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(
      reference.pointer,
      _id_getName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }
}

final class $Build$Partition$NullableType
    extends jni$_.JObjType<Build$Partition?> {
  @jni$_.internal
  const $Build$Partition$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$Partition;';

  @jni$_.internal
  @core$_.override
  Build$Partition? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Build$Partition.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$Partition?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$Partition$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$Partition$NullableType) &&
        other is $Build$Partition$NullableType;
  }
}

final class $Build$Partition$Type extends jni$_.JObjType<Build$Partition> {
  @jni$_.internal
  const $Build$Partition$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$Partition;';

  @jni$_.internal
  @core$_.override
  Build$Partition fromReference(jni$_.JReference reference) =>
      Build$Partition.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$Partition?> get nullableType =>
      const $Build$Partition$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$Partition$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$Partition$Type) &&
        other is $Build$Partition$Type;
  }
}

/// from: `android.os.Build$VERSION`
class Build$VERSION extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build$VERSION> $type;

  @jni$_.internal
  Build$VERSION.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build$VERSION');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build$VERSION$NullableType();
  static const type = $Build$VERSION$Type();
  static final _id_BASE_OS = _class.staticFieldId(
    r'BASE_OS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BASE_OS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BASE_OS =>
      _id_BASE_OS.get(_class, const jni$_.JStringNullableType());

  static final _id_CODENAME = _class.staticFieldId(
    r'CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CODENAME =>
      _id_CODENAME.get(_class, const jni$_.JStringNullableType());

  static final _id_INCREMENTAL = _class.staticFieldId(
    r'INCREMENTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INCREMENTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INCREMENTAL =>
      _id_INCREMENTAL.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_PERFORMANCE_CLASS = _class.staticFieldId(
    r'MEDIA_PERFORMANCE_CLASS',
    r'I',
  );

  /// from: `static public final int MEDIA_PERFORMANCE_CLASS`
  static int get MEDIA_PERFORMANCE_CLASS =>
      _id_MEDIA_PERFORMANCE_CLASS.get(_class, const jni$_.jintType());

  static final _id_PREVIEW_SDK_INT = _class.staticFieldId(
    r'PREVIEW_SDK_INT',
    r'I',
  );

  /// from: `static public final int PREVIEW_SDK_INT`
  static int get PREVIEW_SDK_INT =>
      _id_PREVIEW_SDK_INT.get(_class, const jni$_.jintType());

  static final _id_RELEASE = _class.staticFieldId(
    r'RELEASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE =>
      _id_RELEASE.get(_class, const jni$_.JStringNullableType());

  static final _id_RELEASE_OR_CODENAME = _class.staticFieldId(
    r'RELEASE_OR_CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE_OR_CODENAME =>
      _id_RELEASE_OR_CODENAME.get(_class, const jni$_.JStringNullableType());

  static final _id_RELEASE_OR_PREVIEW_DISPLAY = _class.staticFieldId(
    r'RELEASE_OR_PREVIEW_DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_PREVIEW_DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE_OR_PREVIEW_DISPLAY =>
      _id_RELEASE_OR_PREVIEW_DISPLAY.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_SDK = _class.staticFieldId(r'SDK', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String SDK`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SDK =>
      _id_SDK.get(_class, const jni$_.JStringNullableType());

  static final _id_SDK_INT = _class.staticFieldId(r'SDK_INT', r'I');

  /// from: `static public final int SDK_INT`
  static int get SDK_INT => _id_SDK_INT.get(_class, const jni$_.jintType());

  static final _id_SDK_INT_FULL = _class.staticFieldId(r'SDK_INT_FULL', r'I');

  /// from: `static public final int SDK_INT_FULL`
  static int get SDK_INT_FULL =>
      _id_SDK_INT_FULL.get(_class, const jni$_.jintType());

  static final _id_SECURITY_PATCH = _class.staticFieldId(
    r'SECURITY_PATCH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SECURITY_PATCH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SECURITY_PATCH =>
      _id_SECURITY_PATCH.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build$VERSION() {
    return Build$VERSION.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }
}

final class $Build$VERSION$NullableType extends jni$_.JObjType<Build$VERSION?> {
  @jni$_.internal
  const $Build$VERSION$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION;';

  @jni$_.internal
  @core$_.override
  Build$VERSION? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Build$VERSION.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$VERSION?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$VERSION$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$VERSION$NullableType) &&
        other is $Build$VERSION$NullableType;
  }
}

final class $Build$VERSION$Type extends jni$_.JObjType<Build$VERSION> {
  @jni$_.internal
  const $Build$VERSION$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION;';

  @jni$_.internal
  @core$_.override
  Build$VERSION fromReference(jni$_.JReference reference) =>
      Build$VERSION.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$VERSION?> get nullableType =>
      const $Build$VERSION$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$VERSION$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$VERSION$Type) &&
        other is $Build$VERSION$Type;
  }
}

/// from: `android.os.Build$VERSION_CODES`
class Build$VERSION_CODES extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build$VERSION_CODES> $type;

  @jni$_.internal
  Build$VERSION_CODES.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build$VERSION_CODES');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build$VERSION_CODES$NullableType();
  static const type = $Build$VERSION_CODES$Type();

  /// from: `static public final int BAKLAVA`
  static const BAKLAVA = 36;

  /// from: `static public final int BASE`
  static const BASE = 1;

  /// from: `static public final int BASE_1_1`
  static const BASE_1_1 = 2;

  /// from: `static public final int CUPCAKE`
  static const CUPCAKE = 3;

  /// from: `static public final int CUR_DEVELOPMENT`
  static const CUR_DEVELOPMENT = 10000;

  /// from: `static public final int DONUT`
  static const DONUT = 4;

  /// from: `static public final int ECLAIR`
  static const ECLAIR = 5;

  /// from: `static public final int ECLAIR_0_1`
  static const ECLAIR_0_1 = 6;

  /// from: `static public final int ECLAIR_MR1`
  static const ECLAIR_MR1 = 7;

  /// from: `static public final int FROYO`
  static const FROYO = 8;

  /// from: `static public final int GINGERBREAD`
  static const GINGERBREAD = 9;

  /// from: `static public final int GINGERBREAD_MR1`
  static const GINGERBREAD_MR1 = 10;

  /// from: `static public final int HONEYCOMB`
  static const HONEYCOMB = 11;

  /// from: `static public final int HONEYCOMB_MR1`
  static const HONEYCOMB_MR1 = 12;

  /// from: `static public final int HONEYCOMB_MR2`
  static const HONEYCOMB_MR2 = 13;

  /// from: `static public final int ICE_CREAM_SANDWICH`
  static const ICE_CREAM_SANDWICH = 14;

  /// from: `static public final int ICE_CREAM_SANDWICH_MR1`
  static const ICE_CREAM_SANDWICH_MR1 = 15;

  /// from: `static public final int JELLY_BEAN`
  static const JELLY_BEAN = 16;

  /// from: `static public final int JELLY_BEAN_MR1`
  static const JELLY_BEAN_MR1 = 17;

  /// from: `static public final int JELLY_BEAN_MR2`
  static const JELLY_BEAN_MR2 = 18;

  /// from: `static public final int KITKAT`
  static const KITKAT = 19;

  /// from: `static public final int KITKAT_WATCH`
  static const KITKAT_WATCH = 20;

  /// from: `static public final int LOLLIPOP`
  static const LOLLIPOP = 21;

  /// from: `static public final int LOLLIPOP_MR1`
  static const LOLLIPOP_MR1 = 22;

  /// from: `static public final int M`
  static const M = 23;

  /// from: `static public final int N`
  static const N = 24;

  /// from: `static public final int N_MR1`
  static const N_MR1 = 25;

  /// from: `static public final int O`
  static const O = 26;

  /// from: `static public final int O_MR1`
  static const O_MR1 = 27;

  /// from: `static public final int P`
  static const P = 28;

  /// from: `static public final int Q`
  static const Q = 29;

  /// from: `static public final int R`
  static const R = 30;

  /// from: `static public final int S`
  static const S = 31;

  /// from: `static public final int S_V2`
  static const S_V2 = 32;

  /// from: `static public final int TIRAMISU`
  static const TIRAMISU = 33;

  /// from: `static public final int UPSIDE_DOWN_CAKE`
  static const UPSIDE_DOWN_CAKE = 34;

  /// from: `static public final int VANILLA_ICE_CREAM`
  static const VANILLA_ICE_CREAM = 35;
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build$VERSION_CODES() {
    return Build$VERSION_CODES.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }
}

final class $Build$VERSION_CODES$NullableType
    extends jni$_.JObjType<Build$VERSION_CODES?> {
  @jni$_.internal
  const $Build$VERSION_CODES$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES;';

  @jni$_.internal
  @core$_.override
  Build$VERSION_CODES? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Build$VERSION_CODES.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$VERSION_CODES?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$VERSION_CODES$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$VERSION_CODES$NullableType) &&
        other is $Build$VERSION_CODES$NullableType;
  }
}

final class $Build$VERSION_CODES$Type
    extends jni$_.JObjType<Build$VERSION_CODES> {
  @jni$_.internal
  const $Build$VERSION_CODES$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES;';

  @jni$_.internal
  @core$_.override
  Build$VERSION_CODES fromReference(jni$_.JReference reference) =>
      Build$VERSION_CODES.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$VERSION_CODES?> get nullableType =>
      const $Build$VERSION_CODES$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$VERSION_CODES$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$VERSION_CODES$Type) &&
        other is $Build$VERSION_CODES$Type;
  }
}

/// from: `android.os.Build$VERSION_CODES_FULL`
class Build$VERSION_CODES_FULL extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build$VERSION_CODES_FULL> $type;

  @jni$_.internal
  Build$VERSION_CODES_FULL.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/os/Build$VERSION_CODES_FULL',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build$VERSION_CODES_FULL$NullableType();
  static const type = $Build$VERSION_CODES_FULL$Type();

  /// from: `static public final int BAKLAVA`
  static const BAKLAVA = 3600000;

  /// from: `static public final int BASE`
  static const BASE = 100000;

  /// from: `static public final int BASE_1_1`
  static const BASE_1_1 = 200000;

  /// from: `static public final int CUPCAKE`
  static const CUPCAKE = 300000;

  /// from: `static public final int DONUT`
  static const DONUT = 400000;

  /// from: `static public final int ECLAIR`
  static const ECLAIR = 500000;

  /// from: `static public final int ECLAIR_0_1`
  static const ECLAIR_0_1 = 600000;

  /// from: `static public final int ECLAIR_MR1`
  static const ECLAIR_MR1 = 700000;

  /// from: `static public final int FROYO`
  static const FROYO = 800000;

  /// from: `static public final int GINGERBREAD`
  static const GINGERBREAD = 900000;

  /// from: `static public final int GINGERBREAD_MR1`
  static const GINGERBREAD_MR1 = 1000000;

  /// from: `static public final int HONEYCOMB`
  static const HONEYCOMB = 1100000;

  /// from: `static public final int HONEYCOMB_MR1`
  static const HONEYCOMB_MR1 = 1200000;

  /// from: `static public final int HONEYCOMB_MR2`
  static const HONEYCOMB_MR2 = 1300000;

  /// from: `static public final int ICE_CREAM_SANDWICH`
  static const ICE_CREAM_SANDWICH = 1400000;

  /// from: `static public final int ICE_CREAM_SANDWICH_MR1`
  static const ICE_CREAM_SANDWICH_MR1 = 1500000;

  /// from: `static public final int JELLY_BEAN`
  static const JELLY_BEAN = 1600000;

  /// from: `static public final int JELLY_BEAN_MR1`
  static const JELLY_BEAN_MR1 = 1700000;

  /// from: `static public final int JELLY_BEAN_MR2`
  static const JELLY_BEAN_MR2 = 1800000;

  /// from: `static public final int KITKAT`
  static const KITKAT = 1900000;

  /// from: `static public final int KITKAT_WATCH`
  static const KITKAT_WATCH = 2000000;

  /// from: `static public final int LOLLIPOP`
  static const LOLLIPOP = 2100000;

  /// from: `static public final int LOLLIPOP_MR1`
  static const LOLLIPOP_MR1 = 2200000;

  /// from: `static public final int M`
  static const M = 2300000;

  /// from: `static public final int N`
  static const N = 2400000;

  /// from: `static public final int N_MR1`
  static const N_MR1 = 2500000;

  /// from: `static public final int O`
  static const O = 2600000;

  /// from: `static public final int O_MR1`
  static const O_MR1 = 2700000;

  /// from: `static public final int P`
  static const P = 2800000;

  /// from: `static public final int Q`
  static const Q = 2900000;

  /// from: `static public final int R`
  static const R = 3000000;

  /// from: `static public final int S`
  static const S = 3100000;

  /// from: `static public final int S_V2`
  static const S_V2 = 3200000;

  /// from: `static public final int TIRAMISU`
  static const TIRAMISU = 3300000;

  /// from: `static public final int UPSIDE_DOWN_CAKE`
  static const UPSIDE_DOWN_CAKE = 3400000;

  /// from: `static public final int VANILLA_ICE_CREAM`
  static const VANILLA_ICE_CREAM = 3500000;
}

final class $Build$VERSION_CODES_FULL$NullableType
    extends jni$_.JObjType<Build$VERSION_CODES_FULL?> {
  @jni$_.internal
  const $Build$VERSION_CODES_FULL$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES_FULL;';

  @jni$_.internal
  @core$_.override
  Build$VERSION_CODES_FULL? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : Build$VERSION_CODES_FULL.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$VERSION_CODES_FULL?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$VERSION_CODES_FULL$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$VERSION_CODES_FULL$NullableType) &&
        other is $Build$VERSION_CODES_FULL$NullableType;
  }
}

final class $Build$VERSION_CODES_FULL$Type
    extends jni$_.JObjType<Build$VERSION_CODES_FULL> {
  @jni$_.internal
  const $Build$VERSION_CODES_FULL$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES_FULL;';

  @jni$_.internal
  @core$_.override
  Build$VERSION_CODES_FULL fromReference(jni$_.JReference reference) =>
      Build$VERSION_CODES_FULL.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build$VERSION_CODES_FULL?> get nullableType =>
      const $Build$VERSION_CODES_FULL$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$VERSION_CODES_FULL$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$VERSION_CODES_FULL$Type) &&
        other is $Build$VERSION_CODES_FULL$Type;
  }
}

/// from: `android.os.Build`
class Build extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build> $type;

  @jni$_.internal
  Build.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build$NullableType();
  static const type = $Build$Type();
  static final _id_BOARD = _class.staticFieldId(
    r'BOARD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOARD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BOARD =>
      _id_BOARD.get(_class, const jni$_.JStringNullableType());

  static final _id_BOOTLOADER = _class.staticFieldId(
    r'BOOTLOADER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOOTLOADER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BOOTLOADER =>
      _id_BOOTLOADER.get(_class, const jni$_.JStringNullableType());

  static final _id_BRAND = _class.staticFieldId(
    r'BRAND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BRAND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BRAND =>
      _id_BRAND.get(_class, const jni$_.JStringNullableType());

  static final _id_CPU_ABI = _class.staticFieldId(
    r'CPU_ABI',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CPU_ABI =>
      _id_CPU_ABI.get(_class, const jni$_.JStringNullableType());

  static final _id_CPU_ABI2 = _class.staticFieldId(
    r'CPU_ABI2',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI2`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CPU_ABI2 =>
      _id_CPU_ABI2.get(_class, const jni$_.JStringNullableType());

  static final _id_DEVICE = _class.staticFieldId(
    r'DEVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEVICE =>
      _id_DEVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DISPLAY = _class.staticFieldId(
    r'DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DISPLAY =>
      _id_DISPLAY.get(_class, const jni$_.JStringNullableType());

  static final _id_FINGERPRINT = _class.staticFieldId(
    r'FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FINGERPRINT =>
      _id_FINGERPRINT.get(_class, const jni$_.JStringNullableType());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HARDWARE =>
      _id_HARDWARE.get(_class, const jni$_.JStringNullableType());

  static final _id_HOST = _class.staticFieldId(r'HOST', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String HOST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HOST =>
      _id_HOST.get(_class, const jni$_.JStringNullableType());

  static final _id_ID = _class.staticFieldId(r'ID', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ID =>
      _id_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_MANUFACTURER = _class.staticFieldId(
    r'MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MANUFACTURER =>
      _id_MANUFACTURER.get(_class, const jni$_.JStringNullableType());

  static final _id_MODEL = _class.staticFieldId(
    r'MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MODEL =>
      _id_MODEL.get(_class, const jni$_.JStringNullableType());

  static final _id_ODM_SKU = _class.staticFieldId(
    r'ODM_SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ODM_SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ODM_SKU =>
      _id_ODM_SKU.get(_class, const jni$_.JStringNullableType());

  static final _id_PRODUCT = _class.staticFieldId(
    r'PRODUCT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PRODUCT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PRODUCT =>
      _id_PRODUCT.get(_class, const jni$_.JStringNullableType());

  static final _id_RADIO = _class.staticFieldId(
    r'RADIO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RADIO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RADIO =>
      _id_RADIO.get(_class, const jni$_.JStringNullableType());

  static final _id_SERIAL = _class.staticFieldId(
    r'SERIAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SERIAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SERIAL =>
      _id_SERIAL.get(_class, const jni$_.JStringNullableType());

  static final _id_SKU = _class.staticFieldId(r'SKU', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SKU =>
      _id_SKU.get(_class, const jni$_.JStringNullableType());

  static final _id_SOC_MANUFACTURER = _class.staticFieldId(
    r'SOC_MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SOC_MANUFACTURER =>
      _id_SOC_MANUFACTURER.get(_class, const jni$_.JStringNullableType());

  static final _id_SOC_MODEL = _class.staticFieldId(
    r'SOC_MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SOC_MODEL =>
      _id_SOC_MODEL.get(_class, const jni$_.JStringNullableType());

  static final _id_SUPPORTED_32_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_32_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_32_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_32_BIT_ABIS =>
      _id_SUPPORTED_32_BIT_ABIS.get(
        _class,
        const jni$_.JArrayNullableType<jni$_.JString?>(
          jni$_.JStringNullableType(),
        ),
      );

  static final _id_SUPPORTED_64_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_64_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_64_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_64_BIT_ABIS =>
      _id_SUPPORTED_64_BIT_ABIS.get(
        _class,
        const jni$_.JArrayNullableType<jni$_.JString?>(
          jni$_.JStringNullableType(),
        ),
      );

  static final _id_SUPPORTED_ABIS = _class.staticFieldId(
    r'SUPPORTED_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_ABIS =>
      _id_SUPPORTED_ABIS.get(
        _class,
        const jni$_.JArrayNullableType<jni$_.JString?>(
          jni$_.JStringNullableType(),
        ),
      );

  static final _id_TAGS = _class.staticFieldId(r'TAGS', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String TAGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TAGS =>
      _id_TAGS.get(_class, const jni$_.JStringNullableType());

  static final _id_TIME = _class.staticFieldId(r'TIME', r'J');

  /// from: `static public final long TIME`
  static int get TIME => _id_TIME.get(_class, const jni$_.jlongType());

  static final _id_TYPE = _class.staticFieldId(r'TYPE', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_UNKNOWN = _class.staticFieldId(
    r'UNKNOWN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UNKNOWN`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get UNKNOWN =>
      _id_UNKNOWN.get(_class, const jni$_.JStringNullableType());

  static final _id_USER = _class.staticFieldId(r'USER', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String USER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USER =>
      _id_USER.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build() {
    return Build.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_getFingerprintedPartitions = _class.staticMethodId(
    r'getFingerprintedPartitions',
    r'()Ljava/util/List;',
  );

  static final _getFingerprintedPartitions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.List<android.os.Build$Partition> getFingerprintedPartitions()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Build$Partition?>? getFingerprintedPartitions() {
    return _getFingerprintedPartitions(
      _class.reference.pointer,
      _id_getFingerprintedPartitions as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<Build$Partition?>?>(
      const jni$_.JListNullableType<Build$Partition?>(
        $Build$Partition$NullableType(),
      ),
    );
  }

  static final _id_getMajorSdkVersion = _class.staticMethodId(
    r'getMajorSdkVersion',
    r'(I)I',
  );

  static final _getMajorSdkVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public int getMajorSdkVersion(int i)`
  static int getMajorSdkVersion(int i) {
    return _getMajorSdkVersion(
      _class.reference.pointer,
      _id_getMajorSdkVersion as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_getMinorSdkVersion = _class.staticMethodId(
    r'getMinorSdkVersion',
    r'(I)I',
  );

  static final _getMinorSdkVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public int getMinorSdkVersion(int i)`
  static int getMinorSdkVersion(int i) {
    return _getMinorSdkVersion(
      _class.reference.pointer,
      _id_getMinorSdkVersion as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_getRadioVersion = _class.staticMethodId(
    r'getRadioVersion',
    r'()Ljava/lang/String;',
  );

  static final _getRadioVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.lang.String getRadioVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getRadioVersion() {
    return _getRadioVersion(
      _class.reference.pointer,
      _id_getRadioVersion as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getSerial = _class.staticMethodId(
    r'getSerial',
    r'()Ljava/lang/String;',
  );

  static final _getSerial =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.lang.String getSerial()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getSerial() {
    return _getSerial(
      _class.reference.pointer,
      _id_getSerial as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Build$NullableType extends jni$_.JObjType<Build?> {
  @jni$_.internal
  const $Build$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build;';

  @jni$_.internal
  @core$_.override
  Build? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Build.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$NullableType) &&
        other is $Build$NullableType;
  }
}

final class $Build$Type extends jni$_.JObjType<Build> {
  @jni$_.internal
  const $Build$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build;';

  @jni$_.internal
  @core$_.override
  Build fromReference(jni$_.JReference reference) =>
      Build.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build?> get nullableType => const $Build$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$Type) && other is $Build$Type;
  }
}
